<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Financial | Chart.js</title>
<script src="https://cdn.jsdelivr.net/npm/luxon@3.4.4"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-luxon@1.3.1"></script>
<!-- <link rel="icon" href="./favicon.ico"/> -->
<style>
body{background:black; color:steelblue; font-family:Verdana, Geneva, Tahoma, sans-serif}
.chartSELECTOR {background:steelblue;border-radius: 10px;border: 1px solid lime;
    padding: 0.333%;}
.chartBTN {background:steelblue;border-radius: 10px;border: 1px solid orangered;
    padding: 0.666%;}
.chartBTN:hover{color:aqua;background:black;}
.chartSELECTOR:hover{color:aqua;background:black;}
.chartSELECTOR:focus {border-color: teal;
}/* focus border */
.chartSELECTOR:focus option:checked {background-color:black;color:limegreen;
} /* focused item */
.chartSELECTOR:focus-visible{outline-color: teal;
} /* focused item */
.expanderROW{font-family: monospace;margin:2%4%;width:86%;;border-radius: 44%;
    border: solid 1px #000b0b;padding: 0.22em 2em;
}
/* .expanderTGT{font-family: monospace;margin:2%4%;width:90%;border:solid 1px darkslategrey;} */
.expandCollapseBTN2{color:aqua;background:black;border:solid 1px seagreen;
    width: 1.444em;text-align: center;border-radius: 50%;box-shadow: 1px 1px 1px teal;
    float:right;
}
.expandCollapseBTN2:hover{color:cyan;background:darkblue;;border:solid 1px teal;}
.expandCollapseBTN2:active{color:cyan;background:darkslategrey;border:solid 1px teal;}
</style>
</head>
<body>
<article style="border:solid 1px darkblue; border-radius:22px;
padding:1%; margin:1%;">
    <h1 style="font-size:0.888em; border:solid 1px purple;border-radius:22px;
        padding:1%; margin:1%;box-shadow: 1px 1px 1px blue;margin-bottom: 3%;">
        Chart.js | Advanced Financial ai Visualization</h1>
    
    <section style="width:100%;">
        <canvas id="finChart" style="font-size:0.888em; border:solid 1px limegreen; border-radius:22px;
        padding:1%; margin:1%;"></canvas>
    </section>
    <header class="expanderROW">Query:
        <aside  id="queryVIEWBTN" class="expandCollapseBTN2" onclick="queryExpandCollapseClick()"
            >✴</aside>
    </header>
    <section id="queryVIEW" style="font-size:0.888em; border:solid 1px cyan; border-radius:22px;
    padding:3%; margin:2%; line-height: 2.888em;">
        Bar Type:
        <select id="type" class="chartSELECTOR">
            <option value="candlestick" selected>Candlestick</option>
            <option value="ohlc">OHLC</option>
        </select>
        Scale Type:
        <select id="scale-type" class="chartSELECTOR">
            <option value="linear" selected>Linear</option>
            <option value="logarithmic">Logarithmic</option>
        </select>
        Color Scheme:
        <select id="color-scheme" class="chartSELECTOR">
            <option value="muted" selected>Muted</option>
            <option value="neon">Neon</option>
        </select>
        Border:
        <select id="border" class="chartSELECTOR">
            <option value="true" selected>Yes</option>
            <option value="false">No</option>
        </select>
        Mixed:
        <select id="mixed" class="chartSELECTOR">
            <option value="true">Yes</option>
            <option value="false" selected>No</option>
        </select>
        <button id="update" class="chartBTN">Update</button>
        <button id="randomizeData" class="chartBTN">Randomize Data</button>
    </section>
    <header class="expanderROW">Metadata:
        <aside  id="metadataVIEWBTN" class="expandCollapseBTN2" onclick="metadataExpandCollapseClick()"
            >✴</aside>
    </header>
    <section id="metadataVIEW" style="font-size:0.888em; border:solid 1px cyan; border-radius:22px;
    padding:3%; margin:2%; line-height: 2.888em;">
        Bar Type:
        <select id="type" class="chartSELECTOR">
            <option value="candlestick" selected>Candlestick</option>
            <option value="ohlc">OHLC</option>
        </select>
        Scale Type:
        <select id="scale-type" class="chartSELECTOR">
            <option value="linear" selected>Linear</option>
            <option value="logarithmic">Logarithmic</option>
        </select>
        Color Scheme:
        <select id="color-scheme" class="chartSELECTOR">
            <option value="muted" selected>Muted</option>
            <option value="neon">Neon</option>
        </select>
        Border:
        <select id="border" class="chartSELECTOR">
            <option value="true" selected>Yes</option>
            <option value="false">No</option>
        </select>
        Mixed:
        <select id="mixed" class="chartSELECTOR">
            <option value="true">Yes</option>
            <option value="false" selected>No</option>
        </select>
        <button id="update" class="chartBTN">Update</button>
        <button id="randomizeData" class="chartBTN">Randomize Data</button>
    </section>
    <header class="expanderROW">Config:
        <aside  id="configVIEWBTN" class="expandCollapseBTN2" onclick="configExpandCollapseClick()"
        >✴</aside>
    </header>
    <section id="configVIEW" style="font-size:0.888em; border:solid 1px cyan; border-radius:22px;
    padding:3%; margin:2%; line-height: 2.888em;">
        Bar Type:
        <select id="type" class="chartSELECTOR">
            <option value="candlestick" selected>Candlestick</option>
            <option value="ohlc">OHLC</option>
        </select>
        Scale Type:
        <select id="scale-type" class="chartSELECTOR">
            <option value="linear" selected>Linear</option>
            <option value="logarithmic">Logarithmic</option>
        </select>
        Color Scheme:
        <select id="color-scheme" class="chartSELECTOR">
            <option value="muted" selected>Muted</option>
            <option value="neon">Neon</option>
        </select>
        Border:
        <select id="border" class="chartSELECTOR">
            <option value="true" selected>Yes</option>
            <option value="false">No</option>
        </select>
        Mixed:
        <select id="mixed" class="chartSELECTOR">
            <option value="true">Yes</option>
            <option value="false" selected>No</option>
        </select>
        <button id="update" class="chartBTN">Update</button>
        <button id="randomizeData" class="chartBTN">Randomize Data</button>
    </section>
</article>
<script>
    let ai_viewz = {};
    let queryVIEW = document.getElementById('queryVIEW')
    let queryVIEWBTN = document.getElementById('queryVIEWBTN')
    let metadataVIEW = document.getElementById('metadataVIEW')
    let metadataVIEWBTN = document.getElementById('metadataVIEWBTN')
    let configVIEW = document.getElementById('configVIEW')
    let configVIEWBTN = document.getElementById('configVIEWBTN')
    const displayQueryView = ()=> {
        if(ai_viewz.query_expanded){
            queryVIEWBTN.innerHTML = '❇'
            queryVIEW.style.display = 'block'
        } else {
            queryVIEWBTN.innerHTML = '✴'
            queryVIEW.style.display = 'none'
        }
    }; displayQueryView();
    const queryExpandCollapseClick = ()=>{
        ai_viewz.query_expanded = !ai_viewz.query_expanded;
        displayQueryView(); //RELOAD VIEW. 
    //    //SAVE to LOCAL STORAGE
    //    localStorage.ai_ledger = JSON.stringify(ai_ledger)  
    }    
    const displayMetaDataView = ()=> {
        if(ai_viewz.metadata_expanded){
            metadataVIEWBTN.innerHTML = '❇'
            metadataVIEW.style.display = 'block'
        } else {
            metadataVIEWBTN.innerHTML = '✴'
            metadataVIEW.style.display = 'none'
        }
    }; displayMetaDataView();
    const metadataExpandCollapseClick = ()=>{
        ai_viewz.metadata_expanded = !ai_viewz.metadata_expanded;
        displayMetaDataView(); //RELOAD VIEW. 
    //    //SAVE to LOCAL STORAGE
    //    localStorage.ai_ledger = JSON.stringify(ai_ledger)  
    }    
    const displayConfigView = ()=> {
        if(ai_viewz.metadata_expanded){
            configVIEWBTN.innerHTML = '❇'
            configVIEW.style.display = 'block'
        } else {
            configVIEWBTN.innerHTML = '✴'
            configVIEW.style.display = 'none'
        }
    }; displayConfigView();
    const configExpandCollapseClick = ()=>{
        ai_viewz.metadata_expanded = !ai_viewz.metadata_expanded;
        displayConfigView(); //RELOAD VIEW. 
    //    //SAVE to LOCAL STORAGE
    //    localStorage.ai_ledger = JSON.stringify(ai_ledger)  
    }    
</script>
<script>
    /*!
        * @license
        * chartjs-chart-financial
        * http://chartjs.org/
        * Version: 0.2.0
        *
        * Copyright 2024 Chart.js Contributors
        * Released under the MIT license
        * https://github.com/chartjs/chartjs-chart-financial/blob/master/LICENSE.md
        */
        (function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('chart.js'), require('chart.js/helpers')) :
    typeof define === 'function' && define.amd ? define(['chart.js', 'chart.js/helpers'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.Chart, global.Chart.helpers));
    })(this, (function (chart_js, helpers) { 'use strict';
    
    /**
     * This class is based off controller.bar.js from the upstream Chart.js library
     */
    class FinancialController extends chart_js.BarController {
    
        static overrides = {
        label: '',
    
        parsing: false,
    
        hover: {
            mode: 'label'
        },
        animations: {
            numbers: {
            type: 'number',
            properties: ['x', 'y', 'base', 'width', 'open', 'high', 'low', 'close']
            }
        },
    
        scales: {
            x: {
            type: 'timeseries',
            offset: true,
            ticks: {
                major: {
                enabled: true,
                },
                source: 'data',
                maxRotation: 0,
                autoSkip: true,
                autoSkipPadding: 75,
                sampleSize: 100
            },
            },
            y: {
            type: 'linear'
            }
        },
    
        plugins: {
            tooltip: {
            intersect: false,
            mode: 'index',
            callbacks: {
                label(ctx) {
                const point = ctx.parsed;
    
                if (!helpers.isNullOrUndef(point.y)) {
                    return chart_js.defaults.plugins.tooltip.callbacks.label(ctx);
                }
    
                const {o, h, l, c} = point;
    
                return `O: ${o}  H: ${h}  L: ${l}  C: ${c}`;
                }
            }
            }
        }
        };
    
        getLabelAndValue(index) {
        const me = this;
        const parsed = me.getParsed(index);
        const axis = me._cachedMeta.iScale.axis;
    
        const {o, h, l, c} = parsed;
        const value = `O: ${o}  H: ${h}  L: ${l}  C: ${c}`;
    
        return {
            label: `${me._cachedMeta.iScale.getLabelForValue(parsed[axis])}`,
            value
        };
        }
    
        getUserBounds(scale) {
        const {min, max, minDefined, maxDefined} = scale.getUserBounds();
        return {
            min: minDefined ? min : Number.NEGATIVE_INFINITY,
            max: maxDefined ? max : Number.POSITIVE_INFINITY
        };
        }
    
        /**
         * Implement this ourselves since it doesn't handle high and low values
         * https://github.com/chartjs/Chart.js/issues/7328
         * @protected
         */
        getMinMax(scale) {
        const meta = this._cachedMeta;
        const _parsed = meta._parsed;
        const axis = meta.iScale.axis;
        const otherScale = this._getOtherScale(scale);
        const {min: otherMin, max: otherMax} = this.getUserBounds(otherScale);
    
        if (_parsed.length < 2) {
            return {min: 0, max: 1};
        }
    
        if (scale === meta.iScale) {
            return {min: _parsed[0][axis], max: _parsed[_parsed.length - 1][axis]};
        }
    
        const newParsedData = _parsed.filter(({x}) => x >= otherMin && x < otherMax);
    
        let min = Number.POSITIVE_INFINITY;
        let max = Number.NEGATIVE_INFINITY;
        for (let i = 0; i < newParsedData.length; i++) {
            const data = newParsedData[i];
            min = Math.min(min, data.l);
            max = Math.max(max, data.h);
        }
        return {min, max};
        }
    
        /**
         * @protected
         */
        calculateElementProperties(index, ruler, reset, options) {
        const me = this;
        const vscale = me._cachedMeta.vScale;
        const base = vscale.getBasePixel();
        const ipixels = me._calculateBarIndexPixels(index, ruler, options);
        const data = me.chart.data.datasets[me.index].data[index];
        const open = vscale.getPixelForValue(data.o);
        const high = vscale.getPixelForValue(data.h);
        const low = vscale.getPixelForValue(data.l);
        const close = vscale.getPixelForValue(data.c);
    
        return {
            base: reset ? base : low,
            x: ipixels.center,
            y: (low + high) / 2,
            width: ipixels.size,
            open,
            high,
            low,
            close
        };
        }
    
        draw() {
        const me = this;
        const chart = me.chart;
        const rects = me._cachedMeta.data;
        helpers.clipArea(chart.ctx, chart.chartArea);
        for (let i = 0; i < rects.length; ++i) {
            rects[i].draw(me._ctx);
        }
        helpers.unclipArea(chart.ctx);
        }
    
    }
    
    /**
     * Helper function to get the bounds of the bar regardless of the orientation
     * @param {Rectangle} bar the bar
     * @param {boolean} [useFinalPosition]
     * @return {object} bounds of the bar
     * @private
     */
    function getBarBounds(bar, useFinalPosition) {
        const {x, y, base, width, height} = bar.getProps(['x', 'low', 'high', 'width', 'height'], useFinalPosition);
    
        let left, right, top, bottom, half;
    
        if (bar.horizontal) {
        half = height / 2;
        left = Math.min(x, base);
        right = Math.max(x, base);
        top = y - half;
        bottom = y + half;
        } else {
        half = width / 2;
        left = x - half;
        right = x + half;
        top = Math.min(y, base); // use min because 0 pixel at top of screen
        bottom = Math.max(y, base);
        }
    
        return {left, top, right, bottom};
    }
    
    function inRange(bar, x, y, useFinalPosition) {
        const skipX = x === null;
        const skipY = y === null;
        const bounds = !bar || (skipX && skipY) ? false : getBarBounds(bar, useFinalPosition);
    
        return bounds
            && (skipX || x >= bounds.left && x <= bounds.right)
            && (skipY || y >= bounds.top && y <= bounds.bottom);
    }
    
    class FinancialElement extends chart_js.BarElement {
    
        static defaults = {
        backgroundColors: {
            up: 'rgba(75, 192, 192, 0.5)',
            down: 'rgba(255, 99, 132, 0.5)',
            unchanged: 'rgba(201, 203, 207, 0.5)',
        },
        borderColors: {
            up: 'rgb(75, 192, 192)',
            down: 'rgb(255, 99, 132)',
            unchanged: 'rgb(201, 203, 207)',
        }
        };
    
        height() {
        return this.base - this.y;
        }
    
        inRange(mouseX, mouseY, useFinalPosition) {
        return inRange(this, mouseX, mouseY, useFinalPosition);
        }
    
        inXRange(mouseX, useFinalPosition) {
        return inRange(this, mouseX, null, useFinalPosition);
        }
    
        inYRange(mouseY, useFinalPosition) {
        return inRange(this, null, mouseY, useFinalPosition);
        }
    
        getRange(axis) {
        return axis === 'x' ? this.width / 2 : this.height / 2;
        }
    
        getCenterPoint(useFinalPosition) {
        const {x, low, high} = this.getProps(['x', 'low', 'high'], useFinalPosition);
        return {
            x,
            y: (high + low) / 2
        };
        }
    
        tooltipPosition(useFinalPosition) {
        const {x, open, close} = this.getProps(['x', 'open', 'close'], useFinalPosition);
        return {
            x,
            y: (open + close) / 2
        };
        }
    }
    
    class CandlestickElement extends FinancialElement {
        static id = 'candlestick';
    
        static defaults = {
        ...FinancialElement.defaults,
        borderWidth: 1,
        };
    
        draw(ctx) {
        const me = this;
    
        const {x, open, high, low, close} = me;
    
        let borderColors = me.options.borderColors;
        if (typeof borderColors === 'string') {
            borderColors = {
            up: borderColors,
            down: borderColors,
            unchanged: borderColors
            };
        }
    
        let borderColor;
        if (close < open) {
            borderColor = helpers.valueOrDefault(borderColors ? borderColors.up : undefined, chart_js.defaults.elements.candlestick.borderColors.up);
            ctx.fillStyle = helpers.valueOrDefault(me.options.backgroundColors ? me.options.backgroundColors.up : undefined, chart_js.defaults.elements.candlestick.backgroundColors.up);
        } else if (close > open) {
            borderColor = helpers.valueOrDefault(borderColors ? borderColors.down : undefined, chart_js.defaults.elements.candlestick.borderColors.down);
            ctx.fillStyle = helpers.valueOrDefault(me.options.backgroundColors ? me.options.backgroundColors.down : undefined, chart_js.defaults.elements.candlestick.backgroundColors.down);
        } else {
            borderColor = helpers.valueOrDefault(borderColors ? borderColors.unchanged : undefined, chart_js.defaults.elements.candlestick.borderColors.unchanged);
            ctx.fillStyle = helpers.valueOrDefault(me.backgroundColors ? me.backgroundColors.unchanged : undefined, chart_js.defaults.elements.candlestick.backgroundColors.unchanged);
        }
    
        ctx.lineWidth = helpers.valueOrDefault(me.options.borderWidth, chart_js.defaults.elements.candlestick.borderWidth);
        ctx.strokeStyle = borderColor;
    
        ctx.beginPath();
        ctx.moveTo(x, high);
        ctx.lineTo(x, Math.min(open, close));
        ctx.moveTo(x, low);
        ctx.lineTo(x, Math.max(open, close));
        ctx.stroke();
        ctx.fillRect(x - me.width / 2, close, me.width, open - close);
        ctx.strokeRect(x - me.width / 2, close, me.width, open - close);
        ctx.closePath();
        }
    }
    
    class CandlestickController extends FinancialController {
    
        static id = 'candlestick';
    
        static defaults = {
        ...FinancialController.defaults,
        dataElementType: CandlestickElement.id
        };
    
        static defaultRoutes = chart_js.BarController.defaultRoutes;
    
        updateElements(elements, start, count, mode) {
        const reset = mode === 'reset';
        const ruler = this._getRuler();
        const {sharedOptions, includeOptions} = this._getSharedOptions(start, mode);
    
        for (let i = start; i < start + count; i++) {
            const options = sharedOptions || this.resolveDataElementOptions(i, mode);
    
            const baseProperties = this.calculateElementProperties(i, ruler, reset, options);
    
            if (includeOptions) {
            baseProperties.options = options;
            }
            this.updateElement(elements[i], i, baseProperties, mode);
        }
        }
    
    }
    
    const defaults = chart_js.Chart.defaults;
    
    class OhlcElement extends FinancialElement {
        static id = 'ohlc';
    
        static defaults = {
        ...FinancialElement.defaults,
        lineWidth: 2,
        armLength: null,
        armLengthRatio: 0.8
        };
    
        draw(ctx) {
        const me = this;
    
        const {x, open, high, low, close} = me;
    
        const armLengthRatio = helpers.valueOrDefault(me.armLengthRatio, defaults.elements.ohlc.armLengthRatio);
        let armLength = helpers.valueOrDefault(me.armLength, defaults.elements.ohlc.armLength);
        if (armLength === null) {
            // The width of an ohlc is affected by barPercentage and categoryPercentage
            // This behavior is caused by extending controller.financial, which extends controller.bar
            // barPercentage and categoryPercentage are now set to 1.0 (see controller.ohlc)
            // and armLengthRatio is multipled by 0.5,
            // so that when armLengthRatio=1.0, the arms from neighbour ohcl touch,
            // and when armLengthRatio=0.0, ohcl are just vertical lines.
            armLength = me.width * armLengthRatio * 0.5;
        }
    
        if (close < open) {
            ctx.strokeStyle = helpers.valueOrDefault(me.options.borderColors ? me.options.borderColors.up : undefined, defaults.elements.ohlc.borderColors.up);
        } else if (close > open) {
            ctx.strokeStyle = helpers.valueOrDefault(me.options.borderColors ? me.options.borderColors.down : undefined, defaults.elements.ohlc.borderColors.down);
        } else {
            ctx.strokeStyle = helpers.valueOrDefault(me.options.borderColors ? me.options.borderColors.unchanged : undefined, defaults.elements.ohlc.borderColors.unchanged);
        }
        ctx.lineWidth = helpers.valueOrDefault(me.lineWidth, defaults.elements.ohlc.lineWidth);
    
        ctx.beginPath();
        ctx.moveTo(x, high);
        ctx.lineTo(x, low);
        ctx.moveTo(x - armLength, open);
        ctx.lineTo(x, open);
        ctx.moveTo(x + armLength, close);
        ctx.lineTo(x, close);
        ctx.stroke();
        }
    }
    
    class OhlcController extends FinancialController {
        static id = 'ohlc';
    
        static defaults = {
        ...FinancialController.defaults,
        dataElementType: OhlcElement.id,
        datasets: {
            barPercentage: 1.0,
            categoryPercentage: 1.0
        }
        };
    
        updateElements(elements, start, count, mode) {
        const reset = mode === 'reset';
        const ruler = this._getRuler();
        const {sharedOptions, includeOptions} = this._getSharedOptions(start, mode);
    
        for (let i = start; i < start + count; i++) {
            const options = sharedOptions || this.resolveDataElementOptions(i, mode);
    
            const baseProperties = this.calculateElementProperties(i, ruler, reset, options);
    
            if (includeOptions) {
            baseProperties.options = options;
            }
            this.updateElement(elements[i], i, baseProperties, mode);
        }
        }
    
    }
    
    chart_js.Chart.register(CandlestickController, OhlcController, CandlestickElement, OhlcElement);
    
    }));
    
    
</script>        
<!-- <script type="text/javascript" src="./index.js"></script> -->

<script>
var barCount = 60;
var initialDateStr = new Date().toUTCString();

var ctx = document.getElementById('finChart').getContext('2d');
ctx.canvas.width = 1000;
ctx.canvas.height = 250;

var barData = new Array(barCount);
var lineData = new Array(barCount);

getRandomData(initialDateStr);

var chart = new Chart(ctx, {
  type: 'candlestick',
  data: {
    datasets: [{
      label: 'TKR',
      data: barData,
    }, {
      label: 'Close price',
      type: 'line',
      data: lineData,
      hidden: true,
    }]
  }
});

function randomNumber(min, max) {
  return Math.random() * (max - min) + min;
}

function randomBar(target, index, date, lastClose) {
  var open = +randomNumber(lastClose * 0.95, lastClose * 1.05).toFixed(2);
  var close = +randomNumber(open * 0.95, open * 1.05).toFixed(2);
  var high = +randomNumber(Math.max(open, close), Math.max(open, close) * 1.1).toFixed(2);
  var low = +randomNumber(Math.min(open, close) * 0.9, Math.min(open, close)).toFixed(2);

  if (!target[index]) {
    target[index] = {};
  }

  Object.assign(target[index], {
    x: date.valueOf(),
    o: open,
    h: high,
    l: low,
    c: close
  });

}

function getRandomData(dateStr) {
  var date = luxon.DateTime.fromRFC2822(dateStr);

  for (let i = 0; i < barData.length;) {
    date = date.plus({days: 1});
    if (date.weekday <= 5) {
      randomBar(barData, i, date, i === 0 ? 30 : barData[i - 1].c);
      lineData[i] = {x: barData[i].x, y: barData[i].c};
      i++;
    }
  }
}

var update = function() {
  var dataset = chart.config.data.datasets[0];

  // candlestick vs ohlc
  var type = document.getElementById('type').value;
  chart.config.type = type;

  // linear vs log
  var scaleType = document.getElementById('scale-type').value;
  chart.config.options.scales.y.type = scaleType;

  // color
  var colorScheme = document.getElementById('color-scheme').value;
  if (colorScheme === 'neon') {
    chart.config.data.datasets[0].backgroundColors = {
      up: '#01ff01',
      down: '#fe0000',
      unchanged: '#999',
    };
  } else {
    delete chart.config.data.datasets[0].backgroundColors;
  }

  // border
  var border = document.getElementById('border').value;
  if (border === 'false') {
    dataset.borderColors = 'rgba(0, 0, 0, 0)';
  } else {
    delete dataset.borderColors;
  }

  // mixed charts
  var mixed = document.getElementById('mixed').value;
  if (mixed === 'true') {
    chart.config.data.datasets[1].hidden = false;
  } else {
    chart.config.data.datasets[1].hidden = true;
  }

  chart.update();
};

[...document.getElementsByTagName('select')].forEach(element => element.addEventListener('change', update));

document.getElementById('update').addEventListener('click', update);

document.getElementById('randomizeData').addEventListener('click', function() {
  getRandomData(initialDateStr, barData);
  update();
});
</script>
</body>
</html>
